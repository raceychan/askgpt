import inspect
import types
import typing as ty
from datetime import datetime

import orjson
from fastapi import APIRouter, FastAPI, Request
from fastapi.responses import HTMLResponse
from pydantic import BaseModel, Field

from askgpt.helpers.functions import ClassAttr, attribute
from askgpt.helpers.string import str_to_kebab

"""
RFC 9457
------
https://www.rfc-editor.org/rfc/rfc9457.html


RFC-7807
------
https://datatracker.ietf.org/doc/html/rfc7807

type: string
    A URI reference that identifies the problem type. Ideally, the URI should resolve to human-readable information describing the type, but that’s not necessary. The problem type provides information that’s more specific than the HTTP status code itself.
title: string
    A human-readable description of the problem type, meaning that it should always be the same for the same type.
status: number
    This reflects the HTTP status code and is a convenient way to make problem details self-contained. That way they can be interpreted outside of the context of the HTTP interaction in which they were provided.
detail: string
    A human-readable description of the problem instance, explaining why the problem occurred in this specific case.
instance: string
    A URI reference that identifies the problem instance. Ideally, the URI should resolve to information describing the problem instance, but that’s not necessary.

Examples
------
>>> response:
   HTTP/1.1 403 Forbidden
   Content-Type: application/problem+json
   Content-Language: en
   {
    "type": "https://example.com/probs/out-of-credit", # generated by handleregistry
    "title": "You do not have enough credit.", # error description
    "detail": "Your current balance is 30, but that costs 50.", # error instance message like OutOfCredit("Your current balance is ...")
    "instance": "/account/12345/msgs/abc", # entity_id
    "balance": 30,
    "accounts": ["/account/12345",
                 "/account/67890"]
    "timestamp": "2023-11-28T12:34:56Z",
   }
"""


def iso_now() -> str:
    return datetime.now().isoformat()


class ErrorDetail(BaseModel):
    """
    "type": "https://example.com/probs/out-of-credit",
    "title": "You do not have enough credit."
    "detail": "Your current balance is 30, but that costs 50.",
    "instance": "/account/12345/msgs/abc",
                 "/account/67890"]
    "timestamp": "2023-11-28T12:34:56Z",

    "balance": 30,
    "accounts": ["/account/12345",
    """

    type: str = Field(
        json_schema_extra={
            "title": "type",
            "description": "provides information that’s more specific than the HTTP status code itself.",
            "examples": ["https://example.com/probs/out-of-credit"],
        }
    )
    title: str

    detail: str | None = Field(
        default=None,
        json_schema_extra={
            "title": "detail",
            "description": "deailted description of the problem instance",
            "examples": ["Your current balance is 30, but that costs 50."],
        },
    )
    status: int | None = None
    instance: str | None = None
    timestamp: str = Field(default_factory=iso_now)
    request_id: str | None = None

    def model_dump_json(self, exclude_unset=True, exclude_none=True):
        return super().model_dump_json(
            exclude_unset=exclude_unset, exclude_none=exclude_none
        )


class RFC9457(Exception):
    error_type: ClassAttr[str] | str = ClassAttr(lambda cls: str_to_kebab(cls.__name__))
    error_title: ClassAttr[str] | str = ClassAttr(lambda cls: cls.__doc__ or "")

    def __init__(
        self,
        detail: str,
        *,
        type: str | None = None,
        title: str | None = None,
        instance: str | None = None,
        status: int | None = None,
        timestamp: str | None = None,
    ):

        self._error_detail = ErrorDetail(
            type=type or self.__class__.error_type,
            title=title or self.__class__.error_title,
            detail=detail,
            instance=instance,
            status=status,
        )
        if timestamp:
            self._error_detail.timestamp = timestamp

    @property
    def error_detail(self) -> ErrorDetail:
        return self._error_detail

    @classmethod
    def static_error_detail(cls):
        return ErrorDetail(
            type=cls.error_type, title=cls.error_title
        ).model_json_schema()

    def to_json(self) -> str:
        return self.error_detail.model_dump_json()


class IErrorResponse(ty.Protocol):
    content: ErrorDetail
    headers: dict[str, str]
    status_code: int


type ExceptionHandler[Exc] = ty.Callable[[Request, Exc], IErrorResponse]


@ty.final
class HandlerRegistry[Exc: Exception]:
    """
    Add error handler to fastapi according to their signature
    """

    _handlers: dict[type[Exc] | int, ExceptionHandler[Exc]]

    def __init__(self):
        self._handlers = {}

    def __iter__(
        self,
    ) -> ty.Iterator[tuple[type[Exc] | int, ExceptionHandler[Exc]]]:
        return iter(self._handlers.items())

    @property
    def handlers(self):
        return self._handlers

    def register(self, handler: ExceptionHandler[Exc]) -> None:
        """\
        >>> @HandlerRegistry.register
        def any_error_handler(request: Request, exc: Exception | ty.Literal[500]) -> ErrorResponse:
        """
        exc_type = self._extract_exception(handler)
        exc_types = ty.get_args(exc_type)

        if exc_types:
            for exctype in exc_types:
                self._handlers[exctype] = handler
        else:
            exc_type = ty.cast(type[Exc] | int, exc_type)
            self._handlers[exc_type] = handler

    def inject_handlers(self, app: FastAPI) -> None:
        for exc, handler in self:
            app.add_exception_handler(exc, handler)  # type: ignore

    def build_error_route(self, route_path: str = "/errors"):

        def _generate_error_page(error_title: str = "") -> str:
            doc = """
            <html>
                <div class="tip">
                    [API Errors]
                    {errors}
                </div>
            </html>
            """.strip()
            errs = {exc for exc, _ in self if isinstance(exc, RFC9457)}
            error_tmplt = """
            <li>{err}</li>
            """.strip()
            errors = "\n".join(error_tmplt.format(err=err.error_detail) for err in errs)
            final = doc.format(errors=errors)
            return final

        err_route = APIRouter()
        err_route.get(route_path, tags=[f"{route_path}"], response_class=HTMLResponse)(
            _generate_error_page
        )
        return err_route

    @classmethod
    def _extract_exception(
        cls, handler: ExceptionHandler[Exc]
    ) -> type[Exc] | int | types.UnionType | int:
        sig = inspect.signature(handler)
        _, exc = sig.parameters.values()
        exc_type = exc.annotation
        if exc_type is inspect._empty:  # type: ignore
            raise ValueError(f"handler {handler} has no annotation for {exc.name}")
        return exc_type


handler_registry: ty.Final[HandlerRegistry] = HandlerRegistry[Exception]()
